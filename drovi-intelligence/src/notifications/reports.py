"""Reporting email helpers."""

from __future__ import annotations

import html

import structlog
from sqlalchemy import text

from src.config import get_settings
from src.db.client import get_db_session
from src.notifications.resend import send_resend_email

logger = structlog.get_logger()


def _render_report_html(title: str, summary: str, organization_name: str | None) -> str:
    safe_summary = html.escape(summary)
    header = f"{organization_name} — {title}" if organization_name else title
    return (
        f"<h2>{html.escape(header)}</h2>"
        "<p>Generated by Drovi Intelligence.</p>"
        f"<pre style=\"font-family: 'Inter', 'Helvetica', sans-serif; white-space: pre-wrap;\">{safe_summary}</pre>"
    )


async def resolve_report_recipients(
    organization_id: str,
    fallback_to_members: bool = True,
) -> list[str]:
    async with get_db_session() as session:
        result = await session.execute(
            text(
                """
                SELECT notification_emails
                FROM organizations
                WHERE id = :org_id
                """
            ),
            {"org_id": organization_id},
        )
        row = result.fetchone()
        if row and row.notification_emails:
            return list(row.notification_emails)

        admin_result = await session.execute(
            text(
                """
                SELECT u.email
                FROM memberships m
                JOIN users u ON u.id = m.user_id
                WHERE m.org_id = :org_id AND m.role = 'pilot_admin'
                """
            ),
            {"org_id": organization_id},
        )
        admin_emails = [r.email for r in admin_result.fetchall() if r.email]
        if admin_emails:
            return admin_emails

        if not fallback_to_members:
            return []

        member_result = await session.execute(
            text(
                """
                SELECT u.email
                FROM memberships m
                JOIN users u ON u.id = m.user_id
                WHERE m.org_id = :org_id
                """
            ),
            {"org_id": organization_id},
        )
        return [r.email for r in member_result.fetchall() if r.email]


async def send_report_email(
    *,
    organization_id: str,
    report_title: str,
    summary: str,
    report_type: str,
    organization_name: str | None = None,
) -> bool:
    settings = get_settings()
    if not settings.reports_email_enabled:
        logger.info("Report email disabled", report_type=report_type)
        return False

    recipients = await resolve_report_recipients(
        organization_id,
        fallback_to_members=settings.reports_email_fallback_to_members,
    )
    if not recipients:
        logger.info("No recipients for report email", organization_id=organization_id)
        return False

    subject = report_title
    if organization_name:
        subject = f"{organization_name} — {report_title}"
    if settings.reports_email_subject_prefix:
        subject = f"{settings.reports_email_subject_prefix}{subject}"

    html_body = _render_report_html(report_title, summary, organization_name)
    text_body = summary

    return await send_resend_email(
        to_emails=recipients,
        subject=subject,
        html_body=html_body,
        text_body=text_body,
        tags={"report_type": report_type, "organization_id": organization_id},
    )
