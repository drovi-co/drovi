from __future__ import annotations

import io
import json
from datetime import UTC, datetime
from typing import Any

from src.kernel.serialization import json_dumps_canonical

from .models import RenderedWorkProduct, WorkProductGenerateRequest


def render_work_product(request: WorkProductGenerateRequest) -> RenderedWorkProduct:
    product_type = request.product_type
    if product_type == "email":
        return _render_email(request)
    if product_type == "sheet":
        return _render_sheet(request)
    if product_type == "slides":
        return _render_slides(request)
    if product_type == "doc":
        return _render_doc(request)
    if product_type == "ticket":
        return _render_ticket(request)
    if product_type == "api_action":
        return _render_api_action(request)
    raise ValueError(f"Unsupported work product type: {product_type}")


def _render_email(request: WorkProductGenerateRequest) -> RenderedWorkProduct:
    now = datetime.now(UTC).isoformat()
    title = request.title or "Agent Generated Email"
    payload = request.input_payload
    subject = str(payload.get("subject") or title)
    body_lines = _coerce_lines(payload.get("body_lines"))
    if not body_lines:
        body_lines = [
            request.instructions or "Generated by Drovi AgentOS",
            f"Generated at {now}",
        ]

    citations = _citation_lines(request.evidence_refs)
    all_lines = body_lines + citations
    text_content = "\n".join(all_lines).strip()

    html_lines = [f"<p>{_escape_html(line)}</p>" for line in all_lines if line.strip()]
    html = f"<h2>{_escape_html(subject)}</h2>" + "".join(html_lines)

    envelope = {
        "subject": subject,
        "text": text_content,
        "html": html,
        "generated_at": now,
    }

    return RenderedWorkProduct(
        product_type="email",
        title=title,
        mime_type="text/html",
        extension=".html",
        content_bytes=html.encode("utf-8"),
        text_content=text_content,
        output_payload=envelope,
    )


def _render_sheet(request: WorkProductGenerateRequest) -> RenderedWorkProduct:
    from openpyxl import Workbook

    now = datetime.now(UTC).isoformat()
    title = request.title or "Agent Generated Spreadsheet"
    payload = request.input_payload
    rows_raw = payload.get("rows")
    rows = rows_raw if isinstance(rows_raw, list) else []

    workbook = Workbook()
    sheet = workbook.active
    sheet.title = "Data"

    headers = _sheet_headers(rows)
    if headers:
        sheet.append(headers)
        for row in rows:
            if isinstance(row, dict):
                sheet.append([row.get(header, "") for header in headers])
    else:
        sheet.append(["message", "generated_at"])
        sheet.append([request.instructions or "No structured rows provided", now])

    sheet.append([])
    sheet.append(["evidence_refs", ", ".join(request.evidence_refs)])

    content = io.BytesIO()
    workbook.save(content)
    content.seek(0)

    return RenderedWorkProduct(
        product_type="sheet",
        title=title,
        mime_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        extension=".xlsx",
        content_bytes=content.read(),
        text_content=json.dumps(rows, ensure_ascii=False),
        output_payload={
            "row_count": len(rows),
            "column_count": len(headers),
            "generated_at": now,
        },
    )


def _render_slides(request: WorkProductGenerateRequest) -> RenderedWorkProduct:
    from pptx import Presentation

    now = datetime.now(UTC).isoformat()
    title = request.title or "Agent Generated Slides"
    payload = request.input_payload
    sections = _coerce_lines(payload.get("sections"))
    if not sections:
        sections = [request.instructions or "Generated by Drovi AgentOS"]

    presentation = Presentation()

    title_slide = presentation.slides.add_slide(presentation.slide_layouts[0])
    title_slide.shapes.title.text = title
    subtitle = title_slide.placeholders[1]
    subtitle.text = f"Generated at {now}"

    for section in sections:
        slide = presentation.slides.add_slide(presentation.slide_layouts[1])
        slide.shapes.title.text = section[:120]
        text_frame = slide.shapes.placeholders[1].text_frame
        text_frame.clear()
        bullet = text_frame.paragraphs[0]
        bullet.text = section
        for citation in _citation_lines(request.evidence_refs):
            paragraph = text_frame.add_paragraph()
            paragraph.text = citation
            paragraph.level = 1

    content = io.BytesIO()
    presentation.save(content)
    content.seek(0)

    return RenderedWorkProduct(
        product_type="slides",
        title=title,
        mime_type="application/vnd.openxmlformats-officedocument.presentationml.presentation",
        extension=".pptx",
        content_bytes=content.read(),
        text_content="\n".join(sections),
        output_payload={
            "slide_count": len(presentation.slides),
            "generated_at": now,
        },
    )


def _render_doc(request: WorkProductGenerateRequest) -> RenderedWorkProduct:
    from docx import Document

    now = datetime.now(UTC).isoformat()
    title = request.title or "Agent Generated Document"
    payload = request.input_payload
    sections = _coerce_lines(payload.get("sections"))
    if not sections:
        sections = [request.instructions or "Generated by Drovi AgentOS"]

    document = Document()
    document.add_heading(title, level=1)
    document.add_paragraph(f"Generated at {now}")

    text_segments: list[str] = [title]
    for section in sections:
        document.add_heading(section[:80], level=2)
        body = payload.get("section_bodies", {}).get(section) if isinstance(payload.get("section_bodies"), dict) else None
        paragraph_text = str(body or section)
        document.add_paragraph(paragraph_text)
        text_segments.append(paragraph_text)

    citations = _citation_lines(request.evidence_refs)
    if citations:
        document.add_heading("Evidence", level=2)
        for citation in citations:
            document.add_paragraph(citation)
            text_segments.append(citation)

    content = io.BytesIO()
    document.save(content)
    content.seek(0)

    return RenderedWorkProduct(
        product_type="doc",
        title=title,
        mime_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        extension=".docx",
        content_bytes=content.read(),
        text_content="\n".join(text_segments),
        output_payload={
            "section_count": len(sections),
            "citation_count": len(citations),
            "generated_at": now,
        },
    )


def _render_ticket(request: WorkProductGenerateRequest) -> RenderedWorkProduct:
    now = datetime.now(UTC).isoformat()
    title = request.title or "Agent Generated Ticket"
    payload = {
        "title": title,
        "description": request.instructions or "Generated by Drovi AgentOS",
        "labels": request.input_payload.get("labels") if isinstance(request.input_payload.get("labels"), list) else [],
        "priority": request.input_payload.get("priority") or "medium",
        "evidence_refs": request.evidence_refs,
        "generated_at": now,
    }
    serialized = json_dumps_canonical(payload)
    return RenderedWorkProduct(
        product_type="ticket",
        title=title,
        mime_type="application/json",
        extension=".json",
        content_bytes=serialized.encode("utf-8"),
        text_content=serialized,
        output_payload=payload,
    )


def _render_api_action(request: WorkProductGenerateRequest) -> RenderedWorkProduct:
    now = datetime.now(UTC).isoformat()
    title = request.title or "Agent Generated API Action"
    payload = {
        "title": title,
        "method": request.input_payload.get("method") or "POST",
        "endpoint": request.input_payload.get("endpoint") or "",
        "body": request.input_payload.get("body") if isinstance(request.input_payload.get("body"), dict) else {},
        "evidence_refs": request.evidence_refs,
        "generated_at": now,
    }
    serialized = json_dumps_canonical(payload)
    return RenderedWorkProduct(
        product_type="api_action",
        title=title,
        mime_type="application/json",
        extension=".json",
        content_bytes=serialized.encode("utf-8"),
        text_content=serialized,
        output_payload=payload,
    )


def _coerce_lines(value: Any) -> list[str]:
    if not isinstance(value, list):
        return []
    lines: list[str] = []
    for item in value:
        text = str(item).strip()
        if text:
            lines.append(text)
    return lines


def _citation_lines(evidence_refs: list[str]) -> list[str]:
    return [f"[EVIDENCE:{reference}]" for reference in evidence_refs if reference]


def _sheet_headers(rows: list[Any]) -> list[str]:
    if not rows:
        return []
    header_order: list[str] = []
    for row in rows:
        if not isinstance(row, dict):
            continue
        for key in row.keys():
            column = str(key)
            if column not in header_order:
                header_order.append(column)
    return header_order


def _escape_html(text: str) -> str:
    escaped = text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
    return escaped
