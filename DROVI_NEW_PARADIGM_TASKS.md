# Drovi New Paradigm Tasks (Phased)

This is a full, non‑MVP buildout aligned to the Intent Substrate vision.

---

**Phase 0 — Paradigm Reset and Naming**
- [ ] Define the final vocabulary: Continuum, Actuator, Reality Fabric, Proof Core, Context Loom, Intent Bar.
- [ ] Produce a one‑page “Intent Substrate” narrative for internal alignment.
- [ ] Create the system diagram showing layers and data flow.
- [ ] Decide which systems are authoritative for truth vs evidence vs action.
- [ ] Establish success metrics for truth quality, latency, and trust.

---

**Phase 1 — Reality Instrumentation 2.0**
- [x] Extend the Unified Event Model to include all “reality events,” not only messages.
- [x] Add first‑class event types for decision, commitment, delivery, drift, contradiction.
- [x] Implement a sensor registry with metadata and permissions.
- [x] Build optional OS‑level activity capture (desktop agent) with privacy budgets.
- [x] Add connectors for doc diffs, approvals, and code merges.
- [x] Add evidence attachment pipeline for audio, slides, and images.
- [x] Build ingestion replay with idempotent hashes for all sensors.

---

**Phase 2 — Reality Fabric v2 (Bi‑Temporal Truth)**
- [x] Enforce validFrom/validTo on all nodes and relationships.
- [x] Add “belief vs truth” fields and store update reasons.
- [x] Implement contradiction nodes and resolution workflows.
- [x] Add evidence hash‑chains for tamper‑evident provenance.
- [x] Build time‑slice queries: “state at date X.”
- [x] Implement “what changed” queries with diff summaries.
- [x] Add reality graph export for audit and compliance.

---

**Phase 3 — Proof Core (Verification at Scale)**
- [ ] Implement multi‑pass extraction pipeline: classify → extract → verify → contradict.
- [ ] Enforce “No Evidence → No Persist” for high‑stakes items.
- [ ] Add confidence calibration model with supervised feedback.
- [ ] Build contradiction detector with temporal reasoning.
- [ ] Create evidence‑anchored output schema for every claim.
- [ ] Expand eval harness for hallucination rates and evidence coverage.
- [ ] Add red‑team tests for misleading or adversarial inputs.

---

**Phase 4 — Continuum Runtime (Intent Scheduler)**
- [ ] Define Continuum lifecycle and state machine.
- [ ] Build Continuum DSL for goals, constraints, escalation, and proofs.
- [ ] Implement runtime service to schedule and execute Continuums.
- [ ] Add Continuum persistence, versioning, and rollback.
- [ ] Build escalation rules with policy checks and manual overrides.
- [ ] Add monitoring for stuck or degraded Continuums.

---

**Phase 5 — Actuation Plane (Capability Primitives)**
- [ ] Define Actuator interface with read, draft, stage, execute phases.
- [ ] Create driver SDK for partner integrations.
- [ ] Build permissioned execution layer with action tiering.
- [ ] Add reversible actions and rollback handlers.
- [ ] Implement core drivers: email, docs, calendar, slack, CRM, repo.
- [ ] Add sandbox execution for high‑risk operations.

---

**Phase 6 — Context Loom (Attention Kernel)**
- [ ] Build per‑Continuum context budgets and retrieval limits.
- [ ] Add hybrid retrieval with temporal scoring and freshness decay.
- [ ] Implement context caching and invalidation.
- [ ] Build context summaries tied to evidence only.
- [ ] Add drift detection to prune stale context.

---

**Phase 7 — UI: Intent Bar, Reality Stream, Command Deck**
- [ ] Build global Intent Bar with app‑wide hotkey.
- [ ] Add contextual awareness from active tabs and open views.
- [ ] Support ask/command/delegate modes within the Intent Bar.
- [ ] Implement Reality Stream with proof‑driven playback.
- [ ] Build Command Deck for Continuum operations and kill switches.
- [ ] Add rendered outputs: charts, graphs, tables, maps.
- [ ] Implement JSON‑driven UI rendering for model outputs.
- [ ] Ship a dedicated macOS Drovi Shell app with menu‑bar presence.
- [ ] Implement secure IPC between UI Shell and local Core process.
- [ ] Add macOS Accessibility context capture with explicit permissions.
- [ ] Add focused window capture with consent indicators.
- [ ] Add OCR extraction for non‑text surfaces.
- [ ] Build privacy controls and context expiration UI.
- [ ] Implement “Evidence Lens” hover overlay for instant proof.
- [ ] Add dual‑view toggles: structured state and narrative.

---

**Phase 8 — Trust + Policy Core**
- [ ] Build policy‑as‑code runtime with role and sensitivity classes.
- [ ] Add approval gates and confirmation UX.
- [ ] Implement tamper‑evident audit ledger for all actions.
- [ ] Add privacy controls and data minimization policies.
- [ ] Build user‑visible trust indicators and confidence reasoning.

---

**Phase 9 — Simulation and Counterfactual Engine**
- [ ] Build a decision simulation engine for “what if” analysis.
- [ ] Add outcome prediction for commitments and risks.
- [ ] Implement Continuum previews with expected outcomes.
- [ ] Add sensitivity analysis for high‑impact actions.

---

**Phase 10 — Continuum Exchange (Marketplace)**
- [ ] Define Continuum packaging format and metadata.
- [ ] Build a curated Continuum library with governance rules.
- [ ] Add driver dependency resolution for Continuums.
- [ ] Implement marketplace distribution with signed bundles.
- [ ] Add monetization and versioning controls.

---

**Phase 11 — Enterprise Readiness**
- [ ] Complete SOC2‑aligned audit logging and data retention.
- [ ] Implement multi‑tenant policy boundaries and SSO/SCIM.
- [ ] Build disaster recovery and backup automation.
- [ ] Establish SLOs for truth latency and verification.
- [ ] Add operational dashboards for Continuum health.

---

**Phase 12 — Category Launch**
- [ ] Build keynote demo with 3 Continuums running in real time.
- [ ] Produce a 5‑minute launch script and OS‑level narrative.
- [ ] Prepare a public “Intent Substrate” diagram.
- [ ] Launch with 3 flagship Continuums: Renewal, Delivery, Board.
