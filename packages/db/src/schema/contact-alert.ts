// =============================================================================
// CONTACT ALERT SCHEMA
// =============================================================================
//
// Proactive monitoring alerts for contact relationship management.
// Triggers for VIP silence, relationship degradation, commitment breaches, etc.
//

import { randomUUID } from "node:crypto";
import { relations } from "drizzle-orm";
import {
  index,
  jsonb,
  pgEnum,
  pgTable,
  text,
  timestamp,
} from "drizzle-orm/pg-core";
import { contact } from "./intelligence";
import { organization } from "./organization";
import { user } from "./auth";

// =============================================================================
// ENUMS
// =============================================================================

/**
 * Types of alerts that can be generated for contacts.
 */
export const contactAlertTypeEnum = pgEnum("contact_alert_type", [
  // Engagement alerts
  "vip_silence", // VIP contact hasn't responded in X days
  "relationship_degradation", // Sentiment/engagement dropping
  "long_silence", // Any contact silent for extended period
  "engagement_spike", // Unusual increase in activity (good or concerning)

  // Commitment-related
  "commitment_breach_pattern", // Multiple overdue commitments
  "pending_commitment_risk", // Upcoming commitment at risk

  // Decision-related
  "decision_reversal", // Contact reversing previous decisions
  "decision_delay", // Expected decision not made

  // Opportunity alerts
  "reengagement_opportunity", // Good time to reach out
  "introduction_opportunity", // Can connect two contacts
  "deal_risk", // Signs of deal at risk

  // Data quality
  "duplicate_detected", // Potential duplicate contact
  "missing_data", // Important fields missing
  "stale_data", // Data hasn't been updated in long time
]);

/**
 * Alert severity levels.
 */
export const alertSeverityEnum = pgEnum("alert_severity", [
  "low", // Informational, no action needed
  "medium", // Worth reviewing when convenient
  "high", // Should address soon
  "critical", // Needs immediate attention
]);

/**
 * Alert status for tracking workflow.
 */
export const alertStatusEnum = pgEnum("alert_status", [
  "active", // Alert is active and needs attention
  "acknowledged", // User has seen it but not resolved
  "snoozed", // User snoozed until later
  "resolved", // Issue has been resolved
  "dismissed", // User dismissed as not relevant
  "auto_resolved", // System auto-resolved (situation improved)
]);

// =============================================================================
// TYPE DEFINITIONS
// =============================================================================

/**
 * Additional context data for alerts.
 */
export interface ContactAlertContext {
  // For silence alerts
  daysSilent?: number;
  lastInteractionDate?: string;
  expectedResponseTime?: number;

  // For degradation alerts
  previousScore?: number;
  currentScore?: number;
  scoreType?: "sentiment" | "engagement" | "health";
  percentChange?: number;

  // For commitment alerts
  overdueCommitmentIds?: string[];
  overdueCount?: number;
  totalCommitments?: number;

  // For duplicate alerts
  potentialDuplicateId?: string;
  matchConfidence?: number;
  matchReasons?: string[];

  // For opportunity alerts
  suggestedAction?: string;
  relatedContactIds?: string[];

  // Generic
  additionalData?: Record<string, unknown>;
}

/**
 * Snooze configuration.
 */
export interface SnoozeConfig {
  snoozeUntil: string;
  snoozeReason?: string;
  snoozedBy: string;
  snoozedAt: string;
}

// =============================================================================
// CONTACT ALERT TABLE
// =============================================================================

/**
 * Proactive alerts for contact relationship management.
 * Generated by scheduled intelligence tasks.
 */
export const contactAlert = pgTable(
  "contact_alert",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => randomUUID()),

    // Organization scope
    organizationId: text("organization_id")
      .notNull()
      .references(() => organization.id, { onDelete: "cascade" }),

    // Which contact this alert is about
    contactId: text("contact_id")
      .notNull()
      .references(() => contact.id, { onDelete: "cascade" }),

    // Alert details
    alertType: contactAlertTypeEnum("alert_type").notNull(),
    severity: alertSeverityEnum("severity").notNull(),
    message: text("message").notNull(),
    description: text("description"), // Longer explanation

    // Status tracking
    status: alertStatusEnum("status").default("active").notNull(),

    // Workflow tracking
    acknowledgedAt: timestamp("acknowledged_at"),
    acknowledgedBy: text("acknowledged_by").references(() => user.id, {
      onDelete: "set null",
    }),
    resolvedAt: timestamp("resolved_at"),
    resolvedBy: text("resolved_by").references(() => user.id, {
      onDelete: "set null",
    }),
    dismissedAt: timestamp("dismissed_at"),
    dismissedBy: text("dismissed_by").references(() => user.id, {
      onDelete: "set null",
    }),
    dismissReason: text("dismiss_reason"),

    // Snooze support
    snoozeConfig: jsonb("snooze_config").$type<SnoozeConfig>(),

    // Context data for the alert
    context: jsonb("context").$type<ContactAlertContext>(),

    // Deduplication: prevent duplicate alerts for same issue
    alertKey: text("alert_key"), // Unique key for this alert type + contact

    // Timestamps
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(),
    expiresAt: timestamp("expires_at"), // Auto-expire old alerts
  },
  (table) => [
    // Find all alerts for an organization
    index("contact_alert_org_idx").on(table.organizationId),
    // Find alerts for a specific contact
    index("contact_alert_contact_idx").on(table.contactId),
    // Filter by type
    index("contact_alert_type_idx").on(table.alertType),
    // Filter by severity
    index("contact_alert_severity_idx").on(table.severity),
    // Filter by status (most common query)
    index("contact_alert_status_idx").on(table.status),
    // Combined index for dashboard queries
    index("contact_alert_org_status_severity_idx").on(
      table.organizationId,
      table.status,
      table.severity
    ),
    // Deduplication lookup
    index("contact_alert_key_idx").on(table.alertKey),
    // Expire old alerts
    index("contact_alert_expires_idx").on(table.expiresAt),
  ]
);

// =============================================================================
// RELATIONS
// =============================================================================

export const contactAlertRelations = relations(contactAlert, ({ one }) => ({
  organization: one(organization, {
    fields: [contactAlert.organizationId],
    references: [organization.id],
  }),
  contact: one(contact, {
    fields: [contactAlert.contactId],
    references: [contact.id],
  }),
  acknowledgedByUser: one(user, {
    fields: [contactAlert.acknowledgedBy],
    references: [user.id],
  }),
  resolvedByUser: one(user, {
    fields: [contactAlert.resolvedBy],
    references: [user.id],
  }),
  dismissedByUser: one(user, {
    fields: [contactAlert.dismissedBy],
    references: [user.id],
  }),
}));

// =============================================================================
// TYPE EXPORTS
// =============================================================================

export type ContactAlert = typeof contactAlert.$inferSelect;
export type NewContactAlert = typeof contactAlert.$inferInsert;
